import { Buffer } from 'buffer';
import { Immutables } from 'domains/immutables';
import { Instruction } from './instruction';
import { BaseProgram } from './base-program';
import { ParsedCreateInstructionData, ParsedCreateSrcEscrowInstructionData } from './types';
import { AuctionDetails, MerkleLeaf, SolanaAddress } from '../../domains';
import { SvmCrossChainOrder } from '../../cross-chain-order/svm/svm-cross-chain-order';
export declare class SvmSrcEscrowFactory extends BaseProgram {
    static DEFAULT: SvmSrcEscrowFactory;
    private static readonly coder;
    constructor(programId: SolanaAddress);
    static parseCreateInstruction(ix: Instruction): ParsedCreateInstructionData;
    static parseDeploySrcEscrowInstruction(ix: Instruction): ParsedCreateSrcEscrowInstructionData;
    static parsePrivateWithdrawInstruction(ix: Instruction): {
        secret: string;
    };
    static parsePublicWithdrawInstruction(ix: Instruction): {
        secret: string;
    };
    getOrderAccount(orderHash: Buffer): SolanaAddress;
    getEscrowAddress(params: EscrowAddressParams): SolanaAddress;
    createOrder(order: SvmCrossChainOrder, extra: {
        srcTokenProgramId: SolanaAddress;
    }): Instruction;
    createEscrow(immutables: Immutables<SolanaAddress>, auction: AuctionDetails, extra: {
        /**
         * If not passed, than `WhitelistContract.DEFAULT` will be used
         * @see WhitelistContract.DEFAULT
         */
        whitelistProgramId?: SolanaAddress;
        /**
         * TokenProgram or TokenProgram 2022
         */
        tokenProgramId: SolanaAddress;
        /**
         * Required if order allows partial fills
         */
        merkleProof?: {
            /**
             * Merkle proof for index `idx`
             *
             * @see HashLock.getProof
             */
            proof: MerkleLeaf[];
            /**
             * @see SvmCrossChainOrder.getMultipleFillIdx
             */
            idx: number;
            /**
             * Hash of secret at index `idx`
             */
            secretHash: Buffer;
        };
    }): Instruction;
    withdrawPrivate(params: Immutables<SolanaAddress>, secret: Buffer, extra: {
        /**
         * TokenProgram or TokenProgram 2022
         */
        tokenProgramId: SolanaAddress;
    }): Instruction;
    withdrawPublic(params: Immutables<SolanaAddress>, secret: Buffer, resolver: SolanaAddress, extra: {
        /**
         * If not passed, than `WhitelistContract.DEFAULT` will be used
         * @see WhitelistContract.DEFAULT
         */
        whitelistProgramId?: SolanaAddress;
        /**
         * TokenProgram or TokenProgram 2022
         */
        tokenProgramId: SolanaAddress;
    }): Instruction;
}
export type EscrowAddressParams = Pick<Immutables<SolanaAddress>, 'orderHash' | 'hashLock' | 'taker' | 'amount'>;
