"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SvmSrcEscrowFactory = void 0;
const tslib_1 = require("tslib");
const anchor_1 = require("@coral-xyz/anchor");
const assert_1 = tslib_1.__importDefault(require("assert"));
const buffer_1 = require("buffer");
const instruction_1 = require("./instruction");
const base_program_1 = require("./base-program");
const whitelist_1 = require("./whitelist");
const chains_1 = require("../../chains");
const uint_as_be_bytes_1 = require("../../utils/numbers/uint-as-be-bytes");
const domains_1 = require("../../domains");
const utils_1 = require("../../utils");
const cross_chain_escrow_src_1 = require("../../idl/cross-chain-escrow-src");
const uint256_split_1 = require("../../utils/numbers/uint256-split");
const hasher_1 = require("../../domains/auction-details/hasher");
const bigint_to_bn_1 = require("../../utils/numbers/bigint-to-bn");
const bytes_1 = require("../../utils/bytes");
const bn_array_to_big_int_1 = require("../../utils/numbers/bn-array-to-big-int");
const cross_chain_order_1 = require("../../cross-chain-order");
const u24_to_number_1 = require("../../utils/numbers/u24-to-number");
class SvmSrcEscrowFactory extends base_program_1.BaseProgram {
    constructor(programId) {
        super(programId);
    }
    static parseCreateInstruction(ix) {
        const decodeIx = this.coder.instruction.decode(ix.data);
        (0, assert_1.default)(decodeIx, 'cannot decode create instruction');
        (0, assert_1.default)(decodeIx.name === 'create', 'provided not create instruction');
        const data = decodeIx.data;
        const accounts = {
            creator: ix.accounts[0].pubkey,
            mint: ix.accounts[1].pubkey,
            creatorAta: ix.accounts[2].pubkey,
            order: ix.accounts[3].pubkey,
            orderAta: ix.accounts[4].pubkey,
            associatedTokenProgram: ix.accounts[5].pubkey,
            tokenProgram: ix.accounts[6].pubkey,
            rent: ix.accounts[7].pubkey,
            systemProgram: ix.accounts[8].pubkey
        };
        const orderInfo = {
            srcToken: accounts.mint,
            dstToken: domains_1.EvmAddress.fromBuffer(buffer_1.Buffer.from(data.dstChainParams.token)),
            maker: accounts.creator,
            srcAmount: BigInt(data.amount.toString()),
            minDstAmount: (0, bn_array_to_big_int_1.bnArrayToBigInt)(data.dstAmount),
            receiver: domains_1.EvmAddress.fromBuffer(buffer_1.Buffer.from(data.dstChainParams.makerAddress))
        };
        const escrowParams = {
            hashLock: domains_1.HashLock.fromBuffer(buffer_1.Buffer.from(data.hashlock)),
            srcChainId: chains_1.NetworkEnum.SOLANA,
            dstChainId: data.dstChainParams.chainId,
            srcSafetyDeposit: BigInt(data.safetyDeposit.toString()),
            dstSafetyDeposit: BigInt(data.dstChainParams.safetyDeposit.toString()),
            timeLocks: domains_1.TimeLocks.fromBigInt((0, bn_array_to_big_int_1.bnArrayToBigInt)(data.timelocks))
        };
        const extraDetails = {
            srcAssetIsNative: data.assetsIsNative,
            resolverCancellationConfig: new cross_chain_order_1.ResolverCancellationConfig(BigInt(data.maxCancellationPremium), data.cancellationAuctionDuration),
            allowMultipleFills: data.allowMultipleFills,
            salt: BigInt(data.salt.toString())
        };
        return {
            orderInfo,
            escrowParams,
            extraDetails,
            expirationTime: BigInt(data.expirationTime),
            dutchAuctionDataHash: (0, bytes_1.bufferToHex)(data.dutchAuctionDataHash)
        };
    }
    static parseDeploySrcEscrowInstruction(ix) {
        const decodeIx = this.coder.instruction.decode(ix.data);
        (0, assert_1.default)(decodeIx, 'cannot decode create instruction');
        (0, assert_1.default)(decodeIx.name === 'createEscrow', 'not createEscrow instruction');
        const { amount, dutchAuctionData, merkleProof } = decodeIx.data;
        const auction = new domains_1.AuctionDetails({
            startTime: BigInt(dutchAuctionData.startTime),
            duration: BigInt(dutchAuctionData.duration),
            initialRateBump: (0, u24_to_number_1.u24ToNumber)(dutchAuctionData.initialRateBump),
            points: dutchAuctionData.pointsAndTimeDeltas.map((pt) => ({
                coefficient: (0, u24_to_number_1.u24ToNumber)(pt.rateBump),
                delay: pt.timeDelta
            }))
        });
        return {
            amount: BigInt(amount.toString()),
            dutchAuctionData: auction,
            merkleProof: merkleProof
                ? {
                    index: Number(merkleProof.index.toString()),
                    proof: merkleProof.proof.map(bytes_1.bufferToHex),
                    hashedSecret: (0, bytes_1.bufferToHex)(merkleProof.hashedSecret)
                }
                : null
        };
    }
    static parsePrivateWithdrawInstruction(ix) {
        const decoded = this.coder.instruction.decode(ix.data);
        (0, assert_1.default)(decoded, 'cannot decode withdraw instruction');
        (0, assert_1.default)(decoded.name === 'withdraw', 'not withdraw instruction');
        return {
            secret: (0, bytes_1.bufferToHex)(decoded.data.secret)
        };
    }
    static parsePublicWithdrawInstruction(ix) {
        const decoded = this.coder.instruction.decode(ix.data);
        (0, assert_1.default)(decoded, 'cannot decode publicWithdraw instruction');
        (0, assert_1.default)(decoded.name === 'publicWithdraw', 'not publicWithdraw instruction');
        return {
            secret: (0, bytes_1.bufferToHex)(decoded.data.secret)
        };
    }
    getOrderAccount(orderHash) {
        return (0, utils_1.getPda)(this.programId, [this.encoder.encode('order'), orderHash]);
    }
    getEscrowAddress(params) {
        return (0, utils_1.getPda)(this.programId, [
            this.encoder.encode('escrow'),
            params.orderHash,
            params.hashLock.toBuffer(),
            params.taker.toBuffer(),
            (0, uint_as_be_bytes_1.uintAsBeBytes)(params.amount, 64)
        ]);
    }
    createOrder(order, extra) {
        const data = SvmSrcEscrowFactory.coder.instruction.encode('create', {
            hashlock: order.hashLock.toBuffer(),
            amount: new anchor_1.BN(order.makingAmount.toString()),
            safetyDeposit: new anchor_1.BN(order.srcSafetyDeposit.toString()),
            timelocks: (0, uint256_split_1.uint256split)(order.timeLocks.build()).map(bigint_to_bn_1.bigintToBN),
            expirationTime: Number(order.deadline),
            assetIsNative: order.srcAssetIsNative,
            dstAmount: (0, uint256_split_1.uint256split)(order.takingAmount).map(bigint_to_bn_1.bigintToBN),
            dutchAuctionDataHash: (0, hasher_1.hashForSolana)(order.auction),
            maxCancellationPremium: new anchor_1.BN(order.resolverCancellationConfig.maxCancellationPremium.toString()),
            cancellationAuctionDuration: order.resolverCancellationConfig.cancellationAuctionDuration,
            allowMultipleFills: order.multipleFillsAllowed,
            salt: new anchor_1.BN(order.salt.toString()),
            dstChainParams: {
                chainId: order.dstChainId,
                makerAddress: (0, bytes_1.bufferFromHex)(order.receiver.toString(), 32),
                token: (0, bytes_1.bufferFromHex)(order.takerAsset.toString(), 32),
                safetyDeposit: new anchor_1.BN(order.dstSafetyDeposit.toString())
            }
        });
        const orderAccount = order.getOrderAccount(this.programId);
        return new instruction_1.Instruction(this.programId, [
            // 1. maker
            { pubkey: order.maker, isWritable: true, isSigner: true },
            // 2. src mint
            {
                pubkey: order.makerAsset,
                isWritable: false,
                isSigner: false
            },
            // 3. src_maker_ata
            this.optionalAccount({
                pubkey: (0, utils_1.getAta)(order.maker, order.makerAsset, extra.srcTokenProgramId),
                isSigner: false,
                isWritable: true
            }, order.srcAssetIsNative),
            // 4. order
            {
                pubkey: orderAccount,
                isSigner: false,
                isWritable: true
            },
            // 5. order_ata
            {
                pubkey: (0, utils_1.getAta)(orderAccount, order.makerAsset, extra.srcTokenProgramId),
                isSigner: false,
                isWritable: true
            },
            // 6. associated_token_program
            {
                pubkey: domains_1.SolanaAddress.ASSOCIATED_TOKE_PROGRAM_ID,
                isSigner: false,
                isWritable: false
            },
            // 7. token_program
            {
                pubkey: extra.srcTokenProgramId,
                isSigner: false,
                isWritable: false
            },
            // 8. rent
            {
                pubkey: domains_1.SolanaAddress.SYSVAR_RENT_ID,
                isSigner: false,
                isWritable: false
            },
            // 9. system_program
            {
                pubkey: domains_1.SolanaAddress.SYSTEM_PROGRAM_ID,
                isSigner: false,
                isWritable: false
            }
        ], data);
    }
    createEscrow(immutables, auction, extra) {
        const merkleProof = extra.merkleProof || null;
        const whitelistProgram = extra.whitelistProgramId
            ? new whitelist_1.WhitelistContract(extra.whitelistProgramId)
            : whitelist_1.WhitelistContract.DEFAULT;
        const data = SvmSrcEscrowFactory.coder.instruction.encode('createEscrow', {
            amount: new anchor_1.BN(immutables.amount.toString()),
            dutchAuctionData: {
                startTime: Number(auction.startTime),
                duration: Number(auction.duration),
                initialRateBump: [
                    (0, uint_as_be_bytes_1.uintAsBeBytes)(auction.initialRateBump, 24)
                ],
                pointsAndTimeDeltas: auction.points.map((p) => ({
                    rateBump: [(0, uint_as_be_bytes_1.uintAsBeBytes)(BigInt(p.coefficient), 24)],
                    timeDelta: p.delay
                }))
            },
            merkleProof: merkleProof && {
                proof: merkleProof.proof.map((x) => (0, bytes_1.bufferFromHex)(x)),
                index: new anchor_1.BN(merkleProof.idx),
                hashedSecret: merkleProof.secretHash
            }
        });
        const orderAccount = this.getOrderAccount(immutables.orderHash);
        const escrowAddress = this.getEscrowAddress(immutables);
        return new instruction_1.Instruction(this.programId, [
            // 1. taker
            {
                pubkey: immutables.taker,
                isSigner: true,
                isWritable: true
            },
            // 2. resolver_access
            {
                pubkey: whitelistProgram.getAccessAccount(immutables.taker),
                isSigner: false,
                isWritable: false
            },
            // 3. maker
            {
                pubkey: immutables.maker,
                isSigner: false,
                isWritable: true
            },
            // 4. mint
            {
                pubkey: immutables.token,
                isSigner: false,
                isWritable: false
            },
            // 5. order
            {
                pubkey: orderAccount,
                isSigner: false,
                isWritable: true
            },
            // 6. order ata
            {
                pubkey: (0, utils_1.getAta)(orderAccount, immutables.token, extra.tokenProgramId),
                isSigner: false,
                isWritable: true
            },
            // 7. escrow
            {
                pubkey: escrowAddress,
                isSigner: false,
                isWritable: true
            },
            // 8. escrow ata
            {
                pubkey: (0, utils_1.getAta)(escrowAddress, immutables.token, extra.tokenProgramId),
                isSigner: false,
                isWritable: true
            },
            // 9. associated_token_program
            {
                pubkey: domains_1.SolanaAddress.ASSOCIATED_TOKE_PROGRAM_ID,
                isSigner: false,
                isWritable: false
            },
            // 10. token_program
            {
                pubkey: extra.tokenProgramId,
                isSigner: false,
                isWritable: false
            },
            // 11. system_program
            {
                pubkey: domains_1.SolanaAddress.SYSTEM_PROGRAM_ID,
                isSigner: false,
                isWritable: false
            }
        ], data);
    }
    withdrawPrivate(params, secret, extra) {
        const data = SvmSrcEscrowFactory.coder.instruction.encode('withdraw', {
            secret
        });
        const escrowAddress = this.getEscrowAddress(params);
        return new instruction_1.Instruction(this.programId, [
            // 1. taker
            {
                pubkey: params.taker,
                isSigner: true,
                isWritable: true
            },
            // 2. maker asset
            {
                pubkey: params.token,
                isSigner: false,
                isWritable: false
            },
            // 3. escrow
            {
                pubkey: escrowAddress,
                isWritable: true,
                isSigner: false
            },
            // 4. escrow ata
            {
                pubkey: (0, utils_1.getAta)(escrowAddress, params.token, extra.tokenProgramId),
                isSigner: false,
                isWritable: true
            },
            // 5. taker ata
            {
                pubkey: (0, utils_1.getAta)(params.taker, params.token, extra.tokenProgramId),
                isSigner: false,
                isWritable: true
            },
            // 6. token_program
            {
                pubkey: extra.tokenProgramId,
                isSigner: false,
                isWritable: false
            },
            // 7. system_program
            {
                pubkey: domains_1.SolanaAddress.SYSTEM_PROGRAM_ID,
                isSigner: false,
                isWritable: false
            }
        ], data);
    }
    withdrawPublic(params, secret, resolver, extra) {
        const whitelistProgram = extra.whitelistProgramId
            ? new whitelist_1.WhitelistContract(extra.whitelistProgramId)
            : whitelist_1.WhitelistContract.DEFAULT;
        const data = SvmSrcEscrowFactory.coder.instruction.encode('publicWithdraw', {
            secret
        });
        const escrowAddress = this.getEscrowAddress(params);
        return new instruction_1.Instruction(this.programId, [
            // 1. taker
            {
                pubkey: params.taker,
                isSigner: false,
                isWritable: true
            },
            // 2. payer
            {
                pubkey: resolver,
                isSigner: true,
                isWritable: true
            },
            // 3. resolver_access
            {
                pubkey: whitelistProgram.getAccessAccount(resolver),
                isSigner: false,
                isWritable: false
            },
            // 4. mint
            {
                pubkey: params.token,
                isSigner: false,
                isWritable: false
            },
            // 5. escrow
            {
                pubkey: escrowAddress,
                isWritable: true,
                isSigner: false
            },
            // 6. escrow ata
            {
                pubkey: (0, utils_1.getAta)(escrowAddress, params.token, extra.tokenProgramId),
                isSigner: false,
                isWritable: true
            },
            // 7. taker ata
            {
                pubkey: (0, utils_1.getAta)(params.taker, params.token, extra.tokenProgramId),
                isSigner: false,
                isWritable: true
            },
            // 8. token_program
            {
                pubkey: extra.tokenProgramId,
                isSigner: false,
                isWritable: false
            },
            // 9. system_program
            {
                pubkey: domains_1.SolanaAddress.SYSTEM_PROGRAM_ID,
                isSigner: false,
                isWritable: false
            }
        ], data);
    }
}
exports.SvmSrcEscrowFactory = SvmSrcEscrowFactory;
SvmSrcEscrowFactory.DEFAULT = new SvmSrcEscrowFactory(new domains_1.SolanaAddress('2g4JDRMD7G3dK1PHmCnDAycKzd6e5sdhxqGBbs264zwz'));
SvmSrcEscrowFactory.coder = new anchor_1.BorshCoder(cross_chain_escrow_src_1.IDL);
//# sourceMappingURL=svm-src-escrow-factory.js.map