"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SvmCrossChainOrder = void 0;
const tslib_1 = require("tslib");
const byte_utils_1 = require("@1inch/byte-utils");
const fusion_sdk_1 = require("@1inch/fusion-sdk");
const ethers_1 = require("ethers");
const anchor_1 = require("@coral-xyz/anchor");
const assert_1 = tslib_1.__importDefault(require("assert"));
const buffer_1 = require("buffer");
const resolver_cancellation_config_1 = require("./resolver-cancellation-config");
const contracts_1 = require("../../contracts");
const hasher_1 = require("../../domains/auction-details/hasher");
const uint256_borsh_serialized_1 = require("../../utils/numbers/uint256-borsh-serialized");
const uint_as_be_bytes_1 = require("../../utils/numbers/uint-as-be-bytes");
const addresses_1 = require("../../domains/addresses");
const chains_1 = require("../../chains");
const hash_lock_1 = require("../../domains/hash-lock");
const time_locks_1 = require("../../domains/time-locks");
const base_order_1 = require("../base-order");
const utils_1 = require("../../utils");
const auction_details_1 = require("../../domains/auction-details");
const source_track_1 = require("../source-track");
const bytes_1 = require("../../utils/bytes");
class SvmCrossChainOrder extends base_order_1.BaseOrder {
    constructor(orderInfo, escrowParams, details, extra) {
        (0, assert_1.default)((0, chains_1.isSupportedChain)(escrowParams.srcChainId), `Not supported chain ${escrowParams.srcChainId}`);
        (0, assert_1.default)((0, chains_1.isSupportedChain)(escrowParams.dstChainId), `Not supported chain ${escrowParams.dstChainId}`);
        (0, assert_1.default)(escrowParams.srcChainId !== escrowParams.dstChainId, 'Chains must be different');
        super();
        const orderExpirationDelay = extra.orderExpirationDelay ??
            SvmCrossChainOrder.DefaultExtra.orderExpirationDelay;
        (0, utils_1.assertUInteger)(orderExpirationDelay);
        const deadline = details.auction.startTime +
            details.auction.duration +
            orderExpirationDelay;
        (0, utils_1.assertUInteger)(deadline, byte_utils_1.UINT_32_MAX);
        (0, utils_1.assertUInteger)(orderInfo.srcAmount, byte_utils_1.UINT_64_MAX);
        (0, utils_1.assertUInteger)(orderInfo.minDstAmount, byte_utils_1.UINT_64_MAX);
        // todo more asserts
        const source = extra.source ?? SvmCrossChainOrder.DefaultExtra.source;
        const isSaltContainsSource = extra.salt && extra.salt > byte_utils_1.UINT_32_MAX;
        const salt = isSaltContainsSource
            ? extra.salt
            : (0, source_track_1.injectTrackCode)(extra.salt ?? (0, fusion_sdk_1.randBigInt)(byte_utils_1.UINT_32_MAX), source, SvmCrossChainOrder.TRACK_CODE_MASK);
        (0, utils_1.assertUInteger)(salt, byte_utils_1.UINT_64_MAX);
        const resolverCancellationConfig = extra.resolverCancellationConfig ||
            SvmCrossChainOrder.DefaultExtra.resolverCancellationConfig;
        this.details = details;
        this.escrowParams = escrowParams;
        this.orderConfig = {
            ...orderInfo,
            source,
            salt,
            allowMultipleFills: extra.allowMultipleFills ??
                SvmCrossChainOrder.DefaultExtra.allowMultipleFills,
            srcAssetIsNative: extra.srcAssetIsNative || false,
            deadline: Number(deadline),
            resolverCancellationConfig: resolverCancellationConfig,
            orderExpirationDelay
        };
    }
    get auction() {
        return this.details.auction;
    }
    get salt() {
        return this.orderConfig.salt;
    }
    get resolverCancellationConfig() {
        return this.orderConfig.resolverCancellationConfig;
    }
    get hashLock() {
        return this.escrowParams.hashLock;
    }
    get timeLocks() {
        return this.escrowParams.timeLocks;
    }
    get srcSafetyDeposit() {
        return this.escrowParams.srcSafetyDeposit;
    }
    get dstSafetyDeposit() {
        return this.escrowParams.dstSafetyDeposit;
    }
    get dstChainId() {
        return this.escrowParams.dstChainId;
    }
    get maker() {
        return this.orderConfig.maker;
    }
    get makerAsset() {
        return this.orderConfig.srcToken;
    }
    get takerAsset() {
        return this.orderConfig.dstToken;
    }
    get makingAmount() {
        return this.orderConfig.srcAmount;
    }
    get takingAmount() {
        return this.orderConfig.minDstAmount;
    }
    get receiver() {
        return this.orderConfig.receiver;
    }
    get deadline() {
        return BigInt(this.orderConfig.deadline);
    }
    get auctionStartTime() {
        return this.details.auction.startTime;
    }
    get auctionEndTime() {
        return this.auctionStartTime + this.details.auction.duration;
    }
    get partialFillAllowed() {
        return this.orderConfig.allowMultipleFills;
    }
    get multipleFillsAllowed() {
        return this.orderConfig.allowMultipleFills;
    }
    get srcAssetIsNative() {
        return this.orderConfig.srcAssetIsNative;
    }
    get source() {
        return this.orderConfig.source;
    }
    static new(orderInfo, escrowParams, details, extra) {
        return new SvmCrossChainOrder({
            ...orderInfo,
            srcToken: orderInfo.srcToken.isNative()
                ? addresses_1.SolanaAddress.WRAPPED_NATIVE
                : orderInfo.srcToken
        }, escrowParams, details, {
            ...extra,
            srcAssetIsNative: orderInfo.srcToken.isNative()
        });
    }
    static fromContractOrder(data, auction) {
        (0, assert_1.default)(auction
            .hashForSolana()
            .equals((0, bytes_1.bufferFromHex)(data.dutchAuctionDataHash)), 'wrong auction data');
        const details = { auction };
        const extraDetails = {
            ...data.extraDetails,
            orderExpirationDelay: this.calcExpirationDelay(data.expirationTime, auction.startTime, auction.duration)
        };
        return new SvmCrossChainOrder(data.orderInfo, data.escrowParams, details, extraDetails);
    }
    static fromJSON(data) {
        return new SvmCrossChainOrder({
            srcToken: addresses_1.SolanaAddress.fromString(data.orderInfo.srcToken),
            dstToken: addresses_1.EvmAddress.fromString(data.orderInfo.dstToken),
            srcAmount: BigInt(data.orderInfo.srcAmount),
            minDstAmount: BigInt(data.orderInfo.minDstAmount),
            maker: addresses_1.SolanaAddress.fromString(data.orderInfo.maker),
            receiver: addresses_1.EvmAddress.fromString(data.orderInfo.receiver)
        }, {
            dstChainId: data.escrowParams.dstChainId,
            dstSafetyDeposit: BigInt(data.escrowParams.dstSafetyDeposit),
            hashLock: hash_lock_1.HashLock.fromString(data.escrowParams.hashLock),
            srcChainId: data.escrowParams.srcChainId,
            srcSafetyDeposit: BigInt(data.escrowParams.srcSafetyDeposit),
            timeLocks: time_locks_1.TimeLocks.fromBigInt(BigInt(data.escrowParams.timeLocks))
        }, {
            auction: auction_details_1.AuctionDetails.fromJSON({
                ...data.details.auction,
                gasCost: { gasBumpEstimate: '0', gasPriceEstimate: '0' }
            })
        }, {
            allowMultipleFills: data.extra.allowMultipleFills,
            orderExpirationDelay: BigInt(data.extra.orderExpirationDelay),
            salt: BigInt(data.extra.salt),
            resolverCancellationConfig: new resolver_cancellation_config_1.ResolverCancellationConfig(BigInt(data.extra.resolverCancellationConfig
                .maxCancellationPremium), data.extra.resolverCancellationConfig.cancellationAuctionDuration),
            source: data.extra.source,
            srcAssetIsNative: data.extra.srcAssetIsNative
        });
    }
    static getOrderHashBuffer(params) {
        return (0, bytes_1.bufferFromHex)((0, ethers_1.keccak256)(buffer_1.Buffer.concat([
            params.hashLock.toBuffer(),
            params.maker.toBuffer(),
            params.makerAsset.toBuffer(),
            (0, uint_as_be_bytes_1.uintAsBeBytes)(params.makingAmount, 64),
            (0, uint_as_be_bytes_1.uintAsBeBytes)(params.srcSafetyDeposit, 64),
            (0, uint256_borsh_serialized_1.uint256BorchSerialized)(params.timeLocks.build()),
            (0, uint_as_be_bytes_1.uintAsBeBytes)(params.deadline, 32),
            buffer_1.Buffer.from([Number(params.srcAssetIsNative)]),
            (0, uint256_borsh_serialized_1.uint256BorchSerialized)(params.takingAmount),
            (0, hasher_1.hashForSolana)(params.auction),
            (0, uint_as_be_bytes_1.uintAsBeBytes)(params.resolverCancellationConfig
                .maxCancellationPremium, 64),
            (0, uint_as_be_bytes_1.uintAsBeBytes)(BigInt(params.resolverCancellationConfig
                .cancellationAuctionDuration), 32),
            buffer_1.Buffer.from([Number(params.multipleFillsAllowed)]),
            (0, uint_as_be_bytes_1.uintAsBeBytes)(params.salt, 64)
        ])));
    }
    toJSON() {
        const auction = this.auction.toJSON();
        return {
            details: {
                // skip gasCost field
                auction: {
                    duration: auction.duration,
                    initialRateBump: auction.initialRateBump,
                    points: auction.points,
                    startTime: auction.startTime
                }
            },
            orderInfo: {
                srcToken: this.orderConfig.srcToken.toString(),
                dstToken: this.orderConfig.dstToken.toString(),
                maker: this.orderConfig.maker.toString(),
                srcAmount: this.orderConfig.srcAmount.toString(),
                minDstAmount: this.orderConfig.minDstAmount.toString(),
                receiver: this.orderConfig.receiver.toString()
            },
            escrowParams: {
                hashLock: this.hashLock.toString(),
                srcChainId: chains_1.NetworkEnum.SOLANA,
                dstChainId: this.dstChainId,
                srcSafetyDeposit: this.escrowParams.srcSafetyDeposit.toString(),
                dstSafetyDeposit: this.escrowParams.dstSafetyDeposit.toString(),
                timeLocks: this.timeLocks.build().toString()
            },
            extra: {
                srcAssetIsNative: this.srcAssetIsNative,
                orderExpirationDelay: this.orderConfig.orderExpirationDelay.toString(),
                resolverCancellationConfig: this.resolverCancellationConfig.toJSON(),
                source: this.orderConfig.source,
                allowMultipleFills: this.multipleFillsAllowed,
                // use only last bits because high ones set from source
                salt: (this.salt & byte_utils_1.UINT_32_MAX).toString()
            }
        };
    }
    getOrderAccount(
    /**
     * Src escrow factory program id
     */
    programId) {
        return new contracts_1.SvmSrcEscrowFactory(programId).getOrderAccount(this.getOrderHashBuffer());
    }
    /**
     * Returns escrow address - owner of ATA where funds stored after fill
     *
     * @see getSrcEscrowATA to get ATA where funds stored
     */
    getSrcEscrowAddress(
    /**
     * Src escrow factory program id
     */
    programId, 
    /**
     * Address who fill order and create corresponding escrow
     */
    taker, 
    /**
     * HashLock corresponding to the fill amount secret
     * Can be omitted  for orders where `multipleFillsAllowed` is false
     */
    hashLock = this.hashLock) {
        return new contracts_1.SvmSrcEscrowFactory(programId).getEscrowAddress({
            orderHash: this.getOrderHashBuffer(),
            hashLock,
            taker,
            amount: this.makingAmount
        });
    }
    /**
     * Account where funds stored after fill
     */
    getSrcEscrowATA(params) {
        const escrowAddress = this.getSrcEscrowAddress(params.programId, params.taker, params.hashLock);
        return (0, utils_1.getAta)(escrowAddress, this.makerAsset, params.tokenProgramId);
    }
    /**
     * @returns order has in base58 encoding
     */
    getOrderHash(_srcChainId) {
        return anchor_1.utils.bytes.bs58.encode(this.getOrderHashBuffer());
    }
    getOrderHashBuffer() {
        return SvmCrossChainOrder.getOrderHashBuffer(this);
    }
    getCalculator() {
        const details = this.details.auction;
        return new fusion_sdk_1.AuctionCalculator(details.startTime, details.duration, details.initialRateBump, details.points, 0n // no taker fee
        );
    }
}
exports.SvmCrossChainOrder = SvmCrossChainOrder;
SvmCrossChainOrder.TRACK_CODE_MASK = new byte_utils_1.BitMask(32n, 64n);
SvmCrossChainOrder.DefaultExtra = {
    orderExpirationDelay: 12n,
    allowMultipleFills: true,
    source: 'sdk',
    resolverCancellationConfig: resolver_cancellation_config_1.ResolverCancellationConfig.ALMOST_ZERO // to enable cancellation by resolver
};
//# sourceMappingURL=svm-cross-chain-order.js.map