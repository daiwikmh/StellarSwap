"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.QuoterRequest = void 0;
const tslib_1 = require("tslib");
const fusion_sdk_1 = require("@1inch/fusion-sdk");
const assert_1 = tslib_1.__importDefault(require("assert"));
const chains_1 = require("../../chains");
const domains_1 = require("../../domains");
class QuoterRequest {
    // eslint-disable-next-line max-params
    constructor(srcChain, dstChain, srcTokenAddress, dstTokenAddress, amount, walletAddress, enableEstimate = false, permit, fee, source = 'sdk', isPermit2 = false) {
        this.srcChain = srcChain;
        this.dstChain = dstChain;
        this.srcTokenAddress = srcTokenAddress;
        this.dstTokenAddress = dstTokenAddress;
        this.amount = amount;
        this.walletAddress = walletAddress;
        this.enableEstimate = enableEstimate;
        this.permit = permit;
        this.fee = fee;
        this.source = source;
        this.isPermit2 = isPermit2;
        if (srcChain === dstChain) {
            throw new Error('srcChain and dstChain should be different');
        }
        if (this.fee && this.source === 'sdk') {
            throw new Error('cannot use fee without source');
        }
    }
    static isEvmRequest(params) {
        return (0, chains_1.isEvm)(params.srcChain);
    }
    static isSolanaRequest(params) {
        return (0, chains_1.isSolana)(params.srcChain);
    }
    static forEVM(params) {
        (0, assert_1.default)((0, chains_1.isEvm)(params.srcChain), 'cannot use non evm quote request for srcChain');
        (0, assert_1.default)((0, fusion_sdk_1.isValidAmount)(params.amount), `${params.amount} is invalid amount`);
        const srcToken = domains_1.EvmAddress.fromString(params.srcTokenAddress);
        const dstToken = (0, domains_1.createAddress)(params.dstTokenAddress, params.dstChain);
        (0, assert_1.default)(!srcToken.isNative(), `cannot swap ${domains_1.EvmAddress.NATIVE}: wrap native currency to it's wrapper fist`);
        if ((0, chains_1.isEvm)(params.dstChain)) {
            (0, assert_1.default)(!dstToken.isZero(), `replace ${domains_1.EvmAddress.ZERO} with ${domains_1.EvmAddress.NATIVE}`);
        }
        return new QuoterRequest(params.srcChain, params.dstChain, srcToken, dstToken, BigInt(params.amount), domains_1.EvmAddress.fromString(params.walletAddress), params.enableEstimate, params.permit, params.fee, params.source, params.isPermit2);
    }
    static forSolana(params) {
        (0, assert_1.default)((0, chains_1.isSolana)(params.srcChain), 'cannot use non solana quote request for srcChain');
        (0, assert_1.default)((0, fusion_sdk_1.isValidAmount)(params.amount), `${params.amount} is invalid amount`);
        const srcToken = domains_1.SolanaAddress.fromString(params.srcTokenAddress);
        const dstToken = (0, domains_1.createAddress)(params.dstTokenAddress, params.dstChain);
        return new QuoterRequest(params.srcChain, params.dstChain, srcToken, dstToken, BigInt(params.amount), domains_1.SolanaAddress.fromString(params.walletAddress), params.enableEstimate, params.permit, params.fee, params.source, params.isPermit2);
    }
    isEvmRequest() {
        return (0, chains_1.isEvm)(this.srcChain);
    }
    isSolanaRequest() {
        return (0, chains_1.isSolana)(this.srcChain);
    }
    build() {
        return {
            srcChain: this.srcChain,
            dstChain: this.dstChain,
            srcTokenAddress: this.srcTokenAddress.toString(),
            dstTokenAddress: this.dstTokenAddress.toString(),
            amount: this.amount.toString(),
            walletAddress: this.walletAddress.toString(),
            enableEstimate: this.enableEstimate,
            permit: this.permit,
            fee: this.fee,
            source: this.source,
            isPermit2: this.isPermit2
        };
    }
}
exports.QuoterRequest = QuoterRequest;
//# sourceMappingURL=quoter.request.js.map