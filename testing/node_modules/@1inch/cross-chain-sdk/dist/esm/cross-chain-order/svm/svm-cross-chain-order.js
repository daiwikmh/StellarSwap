import { BitMask, UINT_32_MAX, UINT_64_MAX } from '@1inch/byte-utils';
import { AuctionCalculator, randBigInt } from '@1inch/fusion-sdk';
import { keccak256 } from 'ethers';
import { utils } from '@coral-xyz/anchor';
import assert from 'assert';
import { Buffer } from 'buffer';
import { ResolverCancellationConfig } from './resolver-cancellation-config';
import { SvmSrcEscrowFactory } from '../../contracts';
import { hashForSolana } from '../../domains/auction-details/hasher';
import { uint256BorchSerialized } from '../../utils/numbers/uint256-borsh-serialized';
import { uintAsBeBytes } from '../../utils/numbers/uint-as-be-bytes';
import { EvmAddress, SolanaAddress } from '../../domains/addresses';
import { isSupportedChain, NetworkEnum } from '../../chains';
import { HashLock } from '../../domains/hash-lock';
import { TimeLocks } from '../../domains/time-locks';
import { BaseOrder } from '../base-order';
import { assertUInteger, getAta } from '../../utils';
import { AuctionDetails } from '../../domains/auction-details';
import { injectTrackCode } from '../source-track';
import { bufferFromHex } from '../../utils/bytes';
export class SvmCrossChainOrder extends BaseOrder {
    constructor(orderInfo, escrowParams, details, extra) {
        assert(isSupportedChain(escrowParams.srcChainId), `Not supported chain ${escrowParams.srcChainId}`);
        assert(isSupportedChain(escrowParams.dstChainId), `Not supported chain ${escrowParams.dstChainId}`);
        assert(escrowParams.srcChainId !== escrowParams.dstChainId, 'Chains must be different');
        super();
        const orderExpirationDelay = extra.orderExpirationDelay ??
            SvmCrossChainOrder.DefaultExtra.orderExpirationDelay;
        assertUInteger(orderExpirationDelay);
        const deadline = details.auction.startTime +
            details.auction.duration +
            orderExpirationDelay;
        assertUInteger(deadline, UINT_32_MAX);
        assertUInteger(orderInfo.srcAmount, UINT_64_MAX);
        assertUInteger(orderInfo.minDstAmount, UINT_64_MAX);
        // todo more asserts
        const source = extra.source ?? SvmCrossChainOrder.DefaultExtra.source;
        const isSaltContainsSource = extra.salt && extra.salt > UINT_32_MAX;
        const salt = isSaltContainsSource
            ? extra.salt
            : injectTrackCode(extra.salt ?? randBigInt(UINT_32_MAX), source, SvmCrossChainOrder.TRACK_CODE_MASK);
        assertUInteger(salt, UINT_64_MAX);
        const resolverCancellationConfig = extra.resolverCancellationConfig ||
            SvmCrossChainOrder.DefaultExtra.resolverCancellationConfig;
        this.details = details;
        this.escrowParams = escrowParams;
        this.orderConfig = {
            ...orderInfo,
            source,
            salt,
            allowMultipleFills: extra.allowMultipleFills ??
                SvmCrossChainOrder.DefaultExtra.allowMultipleFills,
            srcAssetIsNative: extra.srcAssetIsNative || false,
            deadline: Number(deadline),
            resolverCancellationConfig: resolverCancellationConfig,
            orderExpirationDelay
        };
    }
    get auction() {
        return this.details.auction;
    }
    get salt() {
        return this.orderConfig.salt;
    }
    get resolverCancellationConfig() {
        return this.orderConfig.resolverCancellationConfig;
    }
    get hashLock() {
        return this.escrowParams.hashLock;
    }
    get timeLocks() {
        return this.escrowParams.timeLocks;
    }
    get srcSafetyDeposit() {
        return this.escrowParams.srcSafetyDeposit;
    }
    get dstSafetyDeposit() {
        return this.escrowParams.dstSafetyDeposit;
    }
    get dstChainId() {
        return this.escrowParams.dstChainId;
    }
    get maker() {
        return this.orderConfig.maker;
    }
    get makerAsset() {
        return this.orderConfig.srcToken;
    }
    get takerAsset() {
        return this.orderConfig.dstToken;
    }
    get makingAmount() {
        return this.orderConfig.srcAmount;
    }
    get takingAmount() {
        return this.orderConfig.minDstAmount;
    }
    get receiver() {
        return this.orderConfig.receiver;
    }
    get deadline() {
        return BigInt(this.orderConfig.deadline);
    }
    get auctionStartTime() {
        return this.details.auction.startTime;
    }
    get auctionEndTime() {
        return this.auctionStartTime + this.details.auction.duration;
    }
    get partialFillAllowed() {
        return this.orderConfig.allowMultipleFills;
    }
    get multipleFillsAllowed() {
        return this.orderConfig.allowMultipleFills;
    }
    get srcAssetIsNative() {
        return this.orderConfig.srcAssetIsNative;
    }
    get source() {
        return this.orderConfig.source;
    }
    static new(orderInfo, escrowParams, details, extra) {
        return new SvmCrossChainOrder({
            ...orderInfo,
            srcToken: orderInfo.srcToken.isNative()
                ? SolanaAddress.WRAPPED_NATIVE
                : orderInfo.srcToken
        }, escrowParams, details, {
            ...extra,
            srcAssetIsNative: orderInfo.srcToken.isNative()
        });
    }
    static fromContractOrder(data, auction) {
        assert(auction
            .hashForSolana()
            .equals(bufferFromHex(data.dutchAuctionDataHash)), 'wrong auction data');
        const details = { auction };
        const extraDetails = {
            ...data.extraDetails,
            orderExpirationDelay: this.calcExpirationDelay(data.expirationTime, auction.startTime, auction.duration)
        };
        return new SvmCrossChainOrder(data.orderInfo, data.escrowParams, details, extraDetails);
    }
    static fromJSON(data) {
        return new SvmCrossChainOrder({
            srcToken: SolanaAddress.fromString(data.orderInfo.srcToken),
            dstToken: EvmAddress.fromString(data.orderInfo.dstToken),
            srcAmount: BigInt(data.orderInfo.srcAmount),
            minDstAmount: BigInt(data.orderInfo.minDstAmount),
            maker: SolanaAddress.fromString(data.orderInfo.maker),
            receiver: EvmAddress.fromString(data.orderInfo.receiver)
        }, {
            dstChainId: data.escrowParams.dstChainId,
            dstSafetyDeposit: BigInt(data.escrowParams.dstSafetyDeposit),
            hashLock: HashLock.fromString(data.escrowParams.hashLock),
            srcChainId: data.escrowParams.srcChainId,
            srcSafetyDeposit: BigInt(data.escrowParams.srcSafetyDeposit),
            timeLocks: TimeLocks.fromBigInt(BigInt(data.escrowParams.timeLocks))
        }, {
            auction: AuctionDetails.fromJSON({
                ...data.details.auction,
                gasCost: { gasBumpEstimate: '0', gasPriceEstimate: '0' }
            })
        }, {
            allowMultipleFills: data.extra.allowMultipleFills,
            orderExpirationDelay: BigInt(data.extra.orderExpirationDelay),
            salt: BigInt(data.extra.salt),
            resolverCancellationConfig: new ResolverCancellationConfig(BigInt(data.extra.resolverCancellationConfig
                .maxCancellationPremium), data.extra.resolverCancellationConfig.cancellationAuctionDuration),
            source: data.extra.source,
            srcAssetIsNative: data.extra.srcAssetIsNative
        });
    }
    static getOrderHashBuffer(params) {
        return bufferFromHex(keccak256(Buffer.concat([
            params.hashLock.toBuffer(),
            params.maker.toBuffer(),
            params.makerAsset.toBuffer(),
            uintAsBeBytes(params.makingAmount, 64),
            uintAsBeBytes(params.srcSafetyDeposit, 64),
            uint256BorchSerialized(params.timeLocks.build()),
            uintAsBeBytes(params.deadline, 32),
            Buffer.from([Number(params.srcAssetIsNative)]),
            uint256BorchSerialized(params.takingAmount),
            hashForSolana(params.auction),
            uintAsBeBytes(params.resolverCancellationConfig
                .maxCancellationPremium, 64),
            uintAsBeBytes(BigInt(params.resolverCancellationConfig
                .cancellationAuctionDuration), 32),
            Buffer.from([Number(params.multipleFillsAllowed)]),
            uintAsBeBytes(params.salt, 64)
        ])));
    }
    toJSON() {
        const auction = this.auction.toJSON();
        return {
            details: {
                // skip gasCost field
                auction: {
                    duration: auction.duration,
                    initialRateBump: auction.initialRateBump,
                    points: auction.points,
                    startTime: auction.startTime
                }
            },
            orderInfo: {
                srcToken: this.orderConfig.srcToken.toString(),
                dstToken: this.orderConfig.dstToken.toString(),
                maker: this.orderConfig.maker.toString(),
                srcAmount: this.orderConfig.srcAmount.toString(),
                minDstAmount: this.orderConfig.minDstAmount.toString(),
                receiver: this.orderConfig.receiver.toString()
            },
            escrowParams: {
                hashLock: this.hashLock.toString(),
                srcChainId: NetworkEnum.SOLANA,
                dstChainId: this.dstChainId,
                srcSafetyDeposit: this.escrowParams.srcSafetyDeposit.toString(),
                dstSafetyDeposit: this.escrowParams.dstSafetyDeposit.toString(),
                timeLocks: this.timeLocks.build().toString()
            },
            extra: {
                srcAssetIsNative: this.srcAssetIsNative,
                orderExpirationDelay: this.orderConfig.orderExpirationDelay.toString(),
                resolverCancellationConfig: this.resolverCancellationConfig.toJSON(),
                source: this.orderConfig.source,
                allowMultipleFills: this.multipleFillsAllowed,
                // use only last bits because high ones set from source
                salt: (this.salt & UINT_32_MAX).toString()
            }
        };
    }
    getOrderAccount(
    /**
     * Src escrow factory program id
     */
    programId) {
        return new SvmSrcEscrowFactory(programId).getOrderAccount(this.getOrderHashBuffer());
    }
    /**
     * Returns escrow address - owner of ATA where funds stored after fill
     *
     * @see getSrcEscrowATA to get ATA where funds stored
     */
    getSrcEscrowAddress(
    /**
     * Src escrow factory program id
     */
    programId, 
    /**
     * Address who fill order and create corresponding escrow
     */
    taker, 
    /**
     * HashLock corresponding to the fill amount secret
     * Can be omitted  for orders where `multipleFillsAllowed` is false
     */
    hashLock = this.hashLock) {
        return new SvmSrcEscrowFactory(programId).getEscrowAddress({
            orderHash: this.getOrderHashBuffer(),
            hashLock,
            taker,
            amount: this.makingAmount
        });
    }
    /**
     * Account where funds stored after fill
     */
    getSrcEscrowATA(params) {
        const escrowAddress = this.getSrcEscrowAddress(params.programId, params.taker, params.hashLock);
        return getAta(escrowAddress, this.makerAsset, params.tokenProgramId);
    }
    /**
     * @returns order has in base58 encoding
     */
    getOrderHash(_srcChainId) {
        return utils.bytes.bs58.encode(this.getOrderHashBuffer());
    }
    getOrderHashBuffer() {
        return SvmCrossChainOrder.getOrderHashBuffer(this);
    }
    getCalculator() {
        const details = this.details.auction;
        return new AuctionCalculator(details.startTime, details.duration, details.initialRateBump, details.points, 0n // no taker fee
        );
    }
}
SvmCrossChainOrder.TRACK_CODE_MASK = new BitMask(32n, 64n);
SvmCrossChainOrder.DefaultExtra = {
    orderExpirationDelay: 12n,
    allowMultipleFills: true,
    source: 'sdk',
    resolverCancellationConfig: ResolverCancellationConfig.ALMOST_ZERO // to enable cancellation by resolver
};
//# sourceMappingURL=svm-cross-chain-order.js.map